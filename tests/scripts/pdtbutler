#!/usr/bin/env python

from __future__ import print_function

# Python imports
import uhal
import click
import click_didyoumean
import time
import collections
import traceback
import StringIO
# import operator
import sys
import os
import pyipmi
import pyipmi.interfaces
import binascii
import struct

# PDT imports
import pdt
import pdt.common.definitions as defs
import pdt.cli.toolbox as toolbox
import pdt.cli.system as system
import pdt.cli.io as io
import pdt.cli.master as master
import pdt.cli.exttrig as exttrig
import pdt.cli.align as align
import pdt.cli.endpoint as endpoint
import pdt.cli.crt as crt
import pdt.cli.debug as debug

# 
from click import echo, style, secho
from os.path import join, expandvars

kLogLevelMap = {
        0: pdt.core.kError,
    }

class PDTContext: pass

CONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'])

# ------------------------------------------------------------------------------
@click.group(
    cls=click_didyoumean.DYMGroup,
    context_settings=CONTEXT_SETTINGS,
)
@click.pass_context
@click.option('-c', '--connections', default='${PDT_TESTS}/etc/connections.xml', help='Path to uhal connection file(s)')
@click.option('-t', '--timeout', default=None, help='uhal timeout (sec)')
@click.option('-v', '--verbose', count=True)
@click.option('-g', '--gdb', is_flag=True)
def cli(ctx, connections, timeout, verbose, gdb):
    
    if gdb:
        toolbox.hookDebugger()

    # Set uhal log level
    uhal.setLogLevelTo(uhal.LogLevel.NOTICE)
    pdt.core.setLogThreshold(kLogLevelMap.get(verbose, pdt.core.kDebug1))

    lConnections  = toolbox.sanitizeConnectionPaths(connections)

    ctx.obj.mConnectionManager = uhal.ConnectionManager(str(lConnections))
    ctx.obj.mTimeout = timeout
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
@cli.command()
@click.pass_obj
def list(obj):
    '''
    List known uhal devices.
    '''
    echo ( 'Available IPBus devices')
    for lId in obj.mConnectionManager.getDevices():
        echo ( ' - '+lId )
        
    pass
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
@cli.command('configure-clock-crossbar', short_help='Configures the clock cross-bar on the AFC')
@click.option('--mch-ip-adr','mch_ip_adr', required=False, type=str, default="192.168.121.99", help='IP address of MCH of uTCA crate hosting the AMC')
@click.option('--amc-slot', 'amc_slot', required=True, type=click.IntRange(1, 12), help='Trigger mask (in hex).')
@click.option('--tx-enable-flag', 'tx_enable_flag', required=False, type=toolbox.IntRange(0x0,0xffff), default=0b0000000000100000, help='Output tx enable flags')
@click.option('--xpt-map0', 'xpt_map0', required=False, type=str, default="77777d7777777777", help='Input->output crossbar map 0')
@click.option('--xpt-map1', 'xpt_map1', required=False, type=str, default="7777777777777777", help='Input->output crossbar map 1')
@click.option('--active-xpt-map', 'active_xpt_map', required=False, type=toolbox.IntRange(0x0,0x1), default=0x0, help='Active xpt map')
@click.pass_obj
def configure(obj, mch_ip_adr, amc_slot, tx_enable_flag, xpt_map0, xpt_map1, active_xpt_map):

    if (len(xpt_map0) != 16 or len(xpt_map1) != 16):
        raise click.ClickException("XPT map length must be 16. Lenghts of provided maps are, 0: {}, 1: {}".format(len(xpt_map0), len(xpt_map1)))

    amc_ipmb_addresses= [0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e, 0x80, 0x82, 0x84, 0x86, 0x88]
    amc_ipmb_adr = amc_ipmb_addresses[amc_slot-1]

    interface = pyipmi.interfaces.create_interface('ipmitool', interface_type='lan')
    connection = pyipmi.create_connection(interface)
    
    connection.target = pyipmi.Target(amc_ipmb_adr)
    connection.target.set_routing([(0x81,0x20,0),(0x20,0x82,7),(0x20,amc_ipmb_adr,None)])
    connection.session.set_session_type_rmcp(mch_ip_adr, port=623)
    connection.session.set_auth_type_user('', '')
    connection.session.establish()

    # reset clock cross-bar
    toolbox.writeRegOverIPMI(connection, 0x0, 0x01)

    # input->output map in output order of 0 1 2 3 4 5 6 7 8 9 10 11  12 13 14 15
    toolbox.applyCrossbarXPTMapConfig(connection, xpt_map0, 0)
    toolbox.applyCrossbarXPTMapConfig(connection, xpt_map1, 1)
    
    # select which map is active
    toolbox.writeRegOverIPMI(connection, 0x81, active_xpt_map)

    #enable new config
    toolbox.writeRegOverIPMI(connection, 0x80, 0x01)

    # output tx enable flags in order of 15 -> 0
    toolbox.applyCrossbarTxConfig(connection,tx_enable_flag)

    print("Crossbar config applied")
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
@cli.command('read-clock-crossbar-config', short_help='Reads the config of the clock cross-bar on the AFC')
@click.option('--mch-ip-adr','mch_ip_adr', required=False, type=str, default="192.168.121.99", help='IP address of MCH of uTCA crate hosting the AMC')
@click.option('--amc-slot', 'amc_slot', required=True, type=click.IntRange(1, 12), help='Trigger mask (in hex).')
@click.pass_obj
def readclockcrossbarconfig(obj, mch_ip_adr, amc_slot):
	amc_ipmb_addresses= [0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e, 0x80, 0x82, 0x84, 0x86, 0x88]
	amc_ipmb_adr = amc_ipmb_addresses[amc_slot-1]
	
	interface = pyipmi.interfaces.create_interface('ipmitool', interface_type='lan')
	connection = pyipmi.create_connection(interface)

	connection.target = pyipmi.Target(amc_ipmb_adr)
	connection.target.set_routing([(0x81,0x20,0),(0x20,0x82,7),(0x20,amc_ipmb_adr,None)])
	connection.session.set_session_type_rmcp(mch_ip_adr, port=623)
	connection.session.set_auth_type_user('', '')
	connection.session.establish()
	
	xpt_map_0 = toolbox.readCrossbarXPTMapConfig(connection, 0)
	xpt_map_1 = toolbox.readCrossbarXPTMapConfig(connection, 1)
	tx_states = toolbox.readCrossbarTxConfig(connection)
	

	active_map = toolbox.readRegOverIPMI(connection, 0x81)
	print("Active map: ",active_map)
	echo  ( toolbox.formatCrossbarConfigTable(xpt_map_0, xpt_map_1, tx_states,active_map) )
# ------------------------------------------------------------------------------    


# ------------------------------------------------------------------------------
@cli.command('reset-fpga-ethernet', short_help='Reset the ethernet block of the FPGA on the AFC')
@click.option('--mch-ip-adr','mch_ip_adr', required=False, type=str, default="192.168.121.99", help='IP address of MCH of uTCA crate hosting the AMC')
@click.option('--amc-slot', 'amc_slot', required=True, type=click.IntRange(1, 12), help='Trigger mask (in hex).')
@click.pass_obj
def resetfpgaethernet(obj, mch_ip_adr, amc_slot):
	amc_ipmb_addresses= [0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e, 0x80, 0x82, 0x84, 0x86, 0x88]
	amc_ipmb_adr = amc_ipmb_addresses[amc_slot-1]
	
	interface = pyipmi.interfaces.create_interface('ipmitool', interface_type='lan')
	connection = pyipmi.create_connection(interface)

	connection.target = pyipmi.Target(amc_ipmb_adr)
	connection.target.set_routing([(0x81,0x20,0),(0x20,0x82,7),(0x20,amc_ipmb_adr,None)])
	connection.session.set_session_type_rmcp(mch_ip_adr, port=623)
	connection.session.set_auth_type_user('', '')
	connection.session.establish()

	port_number=0x2
	#echo( toolbox.readGPIOPortOverIPMI(connection, port_number) )
	
	#mode description: 0 - read port info, 1 - set port dir to in, 2 - set port dir to out with optional value
	toolbox.configureGPIOPortOverIPMI(connection, port_number, 0x2, 0x9,0x1)
	toolbox.configureGPIOPortOverIPMI(connection, port_number, 0x2, 0x9,0x0)
# ------------------------------------------------------------------------------  


# ------------------------------------------------------------------------------
if __name__ == '__main__':
    cli.add_command(system.overlord)
    cli.add_command(system.vst)
    cli.add_command(io.io)
    cli.add_command(master.master)
    cli.add_command(endpoint.endpoint)
    cli.add_command(crt.crt)
    cli.add_command(debug.debug)

    try:
        cli(obj=PDTContext())
    except Exception as e:
        exc_type, exc_obj, exc_tb = sys.exc_info()
        lFirstFrame = traceback.extract_tb(exc_tb)[-1]

        secho("ERROR ('{}' exception): '{}'\n\nFile \"{}\", line {}, in {}\n   {}".format(exc_type.__name__, e, lFirstFrame[0], lFirstFrame[1], lFirstFrame[2], lFirstFrame[3] ),fg='red')
        
        "File \"{}\", line {}, in {}"
        # secho("{}".format(),fg='red')
        # print(lFirstFrame)
        # ipdb.set_trace()
        # fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
        # 'Error: exception of type {} throw'
        # print(e, exc_type.__name__, fname, exc_tb.tb_lineno)
        lExc = StringIO.StringIO()
        traceback.print_exc(file=lExc)
        print ("Exception in user code:")
        print ('-'*60)
        secho(lExc.getvalue(), fg='red')
        print ('-'*60)
# ------------------------------------------------------------------------------
