#!/usr/bin/env python

from __future__ import print_function

# Python imports
import uhal
import click
import click_didyoumean
import time
import collections
# import operator

# PDT imports
import pdt
import pdt.cli.toolbox as toolbox

# 
from click import echo, style, secho
from os.path import join, expandvars

class PDTContext: pass

CONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'])

# ------------------------------------------------------------------------------
@click.group(
    cls=click_didyoumean.DYMGroup,
    context_settings=CONTEXT_SETTINGS,
)
@click.pass_context
@click.option('-c', '--connections', default='${PDT_TESTS}/etc/connections.xml', help='Path to uhal connection file(s)')
@click.option('-t', '--timeout', default=None, help='uhal timeout (sec)')
def cli(ctx, connections, timeout):
    
    # Set uhal log level
    uhal.setLogLevelTo(uhal.LogLevel.NOTICE)

    # click.secho('Connection paths: {}'.format(connections), fg='blue')
    lConnections  = toolbox.sanitizeConnectionPaths(connections)
    # click.secho('Connection paths: {}'.format(lConnections), fg='blue')

    ctx.obj.mConnectionManager = uhal.ConnectionManager(str(lConnections))
    ctx.obj.mTimeout = timeout
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
@cli.command()
@click.pass_obj
def list(obj):
    '''
    List known uhal devices.
    '''
    echo ( 'Available IPBus devices')
    for lId in obj.mConnectionManager.getDevices():
        echo ( ' - '+lId )
        
    pass
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
#    __  ___         __         
#   /  |/  /__ ____ / /____ ____
#  / /|_/ / _ `(_-</ __/ -_) __/
# /_/  /_/\_,_/___/\__/\__/_/   
                              
# -----------------
def validate_device(ctx, param, value):

    lDevices = ctx.obj.mConnectionManager.getDevices()
    if value not in lDevices:
        raise click.BadParameter(
            'Device must be one of '+
            ', '.join(["'"+lId+"'" for lId in lDevices])
            )
    return value
# -----------------


@cli.group('mst', invoke_without_command=True)
@click.pass_obj
@click.argument('device', callback=validate_device)
def master(obj, device):
    '''
    Timing master commands.

    DEVICE: uhal device identifier
    '''
    # print obj.mConnectionManager.getDevices()
    lDevice = obj.mConnectionManager.getDevice(str(device))
    if obj.mTimeout:
        lDevice.setTimeoutPeriod(obj.mTimeout)
        
    echo('Created device ' + click.style(lDevice.id(), fg='blue'))

    lVersion = lDevice.getNode("master.global.version").read()
    lDevice.dispatch()
    echo("Master FW version: "+hex(lVersion))

    obj.mDevice = lDevice
# ------------------------------------------------------------------------------

# def snapshot(node):
#     s = { n:node.getNode(n).read() for n in node.getNodes() }
#     node.getClient().dispatch()
#     return s

# ------------------------------------------------------------------------------
@master.command()
@click.pass_context
def ipy(ctx):
    '''
    Start an interactive IPython session.

    The board HwInterface is accessible as 'lDevice'
    '''
    lDevice = ctx.obj.mDevice

    from IPython import embed
    embed()
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------

kRev1 = 1
kRev2 = 2

kClockConfigMap = {
    kRev1: "SI5344/PDTS0000.txt",
    kRev2: "SI5344/PDTS0003.txt",
}

kBoardRevisionMap = {
    0xd880395e720b: kRev1,
    0xd880395e501a: kRev1,
    0xd880395e50b8: kRev1,
    0xd880395e501b: kRev1,
    0xd880395e7201: kRev1,
    0xd880395e4fcc: kRev1,
    0xd880395e5069: kRev1,
    0xd880395e7206: kRev1,
    0xd880395e1c86: kRev2,
    0xd880395e2630: kRev2,
    0xd880395e262b: kRev2,
    0xd880395e2b38: kRev2,
    0xd880395e1a6a: kRev2,
    0xd880395e36ae: kRev2,
    0xd880395e2b2e: kRev2,
    0xd880395e2b33: kRev2,
    0xd880395e1c81: kRev2,
}

# kBoardRevisionMap = {
# }

@master.command('reset', short_help="Perform a hard reset on the timing master.")
@click.option('--soft', '-s', is_flag=True, help='Target partition', default=False)
@click.pass_obj
def reset(obj, soft):
    '''
    Perform a hard reset on the timing master, including

    \b
    - ipbus registers
    - i2c buses
    - pll and pll configuration
    '''
    echo('Resetting ' + click.style(obj.mDevice.id(), fg='blue'))

    lDevice = obj.mDevice

    # Global soft reset
    lDevice.getNode("io.csr.ctrl.soft_rst").write(0x1)
    lDevice.dispatch()


    if not soft:
        
        time.sleep(1)
        
        # PLL reset
        lDevice.getNode("io.csr.ctrl.pll_rst").write(0x1)
        lDevice.dispatch()
        lDevice.getNode("io.csr.ctrl.pll_rst").write(0x0)
        lDevice.dispatch()

        # Detect the on-board eprom and read the board UID
        lUID = lDevice.getNode("io.uid_i2c")
        echo("UID I2C Slaves")
        for lSlave in lUID.getSlaves():
            echo("  {}: {}".format(lSlave, hex(lUID.getSlaveAddress(lSlave))))

        lUID.getSlave('A').writeI2C(0x01, 0x7f)
        x = lUID.getSlave('A').readI2C(0x01)
        echo("I2C enable lines: {}".format(x))

        lValues = lUID.getSlave('B').readI2CArray(0xfa, 6)
        lUniqueID = 0x0
        for lVal in lValues:
            lUniqueID = ( lUniqueID << 8 ) | lVal
        echo("Timing Board UID: "+style(hex(lUniqueID), fg="blue"))

        # Ensure that the board is known to the revision DB
        try:
            lRevision = kBoardRevisionMap[lUniqueID]
        except KeyError:
            raise click.ClickException("No revision associated to UID "+hex(lUniqueID))

        # Access the clock chip
        lSI5344 = lDevice.getNode('io.pll_i2c')
        lSIVersion = lSI5344.readDeviceVersion()
        echo("PLL version : "+style(hex(lSIVersion), fg='blue'))

        # Ensure that the board revision has a registered clock config
        try:
            lClockConfigPath = kClockConfigMap[lRevision]    
        except KeyError:
            raise ClickException("Board revision " << lRevision << " has no associated clock configuration")

        echo("Clock configuration to load "+style(lClockConfigPath, fg='green') )

        # Configure the clock chip
        lFullClockConfigPath = expandvars(join('${PDT_TESTS}/scripts/ouroboros', lClockConfigPath))
        lSI5344.configure(lFullClockConfigPath)

        # Measure the generated clock frequency
        for i in range(2):
            lDevice.getNode("io.freq.ctrl.chan_sel").write(i)
            lDevice.getNode("io.freq.ctrl.en_crap_mode").write(0)
            lDevice.dispatch()
            time.sleep(2)
            fq = lDevice.getNode("io.freq.freq.count").read()
            fv = lDevice.getNode("io.freq.freq.valid").read()
            lDevice.dispatch()
            print( "Freq:", i, int(fv), int(fq) * 119.20928 / 1000000 )
            
        lDevice.getNode("io.csr.ctrl.sfp_tx_dis").write(0)
        lDevice.dispatch()

    # Reset controls
    lDevice.getNode("io.csr.ctrl.rst").write(1)
    lDevice.dispatch()
    lDevice.getNode("io.csr.ctrl.rst").write(0)
    lDevice.dispatch()

    lGenChanCtrl = lDevice.getNode('master.scmd_gen.chan_ctrl')
    lScmdGenNode = lDevice.getNode('master.scmd_gen')

    echo()
    echo("--- Global status ---")
    lCsrStat = toolbox.readSubNodes(lDevice.getNode('master.global.csr.stat'))
    for k,v in lCsrStat.iteritems():
        echo("{}: {}".format(k, hex(v)))
    echo()

    
    toolbox.resetSubNodes(lGenChanCtrl)
    echo("Disabled command generator")

    lScmdGenNode.getNode('ctrl.en').write(1) # Enable sync command generators
    lDevice.dispatch()
    echo("Time-sync generator enabled")
  

# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
@master.group('part', invoke_without_command=True)
@click.pass_obj
@click.argument('id', type=int)
def partition(obj, id):
    """
    Partition specific commands
    """
    obj.mPartitionId = id
# ------------------------------------------------------------------------------

# Command definition from pdt_defs.vhd
    # constant SCMD_SYNC: std_logic_vector(3 downto 0) := X"0";
    # constant SCMD_ECHO: std_logic_vector(3 downto 0) := X"1";
    # constant SCMD_SPILL_START: std_logic_vector(3 downto 0) := X"2";
    # constant SCMD_SPILL_STOP: std_logic_vector(3 downto 0) := X"3";
    # constant SCMD_RUN_START: std_logic_vector(3 downto 0) := X"4";
    # constant SCMD_RUN_STOP: std_logic_vector(3 downto 0) := X"5";
    # constant SCMD_FAKE_TRIG: std_logic_vector(3 downto 0) := X"8"; -- Commands from 0x8 to 0xf reserved for triggers / calib

kCommandIDs = collections.OrderedDict([

    ('TimeSync', 0x0),
    ('Echo', 0x1),
    ('SpillStart', 0x2),
    ('SpillStop', 0x3),
    ('RunStart', 0x4),
    ('RunStop', 0x5),
    ('FakeTrig', 0x8),
])

kCommandNames = { v:k for k,v in kCommandIDs.iteritems() }

# -----------------
def read_mask(ctx, param, value):
    return int(value, 16)
# -----------------

# ------------------------------------------------------------------------------
@partition.command('configure', short_help='Prepares partition for data taking.')
@click.option('--trgmask', '-m', type=str, callback=read_mask, help='Trigger mask', default='0xff')
@click.pass_obj
def configure(obj, trgmask):
    '''
    Configures partition for data taking

    \b
    - disable command generator (calibration)
    - enable time-sync command generator
    - disable readout buffer
    - disable triggers
    - set command mask for the partition
    - enable partition
    '''
    lDevice = obj.mDevice
    lPartId = obj.mPartitionId

    lGlobalNode = lDevice.getNode('master.global')
    lPartNode = lDevice.getNode('master.partition')

    # Select the desired partition
    lGlobalNode.getNode('csr.ctrl.part_sel').write(lPartId)
    lDevice.dispatch()
    
    echo()
    echo("Configuring partition {}".format(lPartId))
    echo("Trigger mask set to {}".format(hex(trgmask)))

    lPartNode.reset(); 
    lPartNode.setCommandMask(trgmask);
    lPartNode.enable();
    secho("Partition {} enabled".format(lPartId), fg='green')

# ------------------------------------------------------------------------------



# ------------------------------------------------------------------------------
@partition.command('start', short_help='Starts data taking.')
@click.pass_obj
def start(obj):

    '''
    Starts a new run
    
    \b
    - flushes the partition buffer
    - set the command mask
    - enables the readout buffer
    - enables triggers
    '''
    lDevice = obj.mDevice
    lPartId = obj.mPartitionId

    lGlobalNode = lDevice.getNode('master.global')
    lPartNode = lDevice.getNode('master.partition')

    # Select the desired partition
    lGlobalNode.getNode('csr.ctrl.part_sel').write(lPartId)
    lDevice.dispatch()

    lPartNode.start();
    pass
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
@partition.command('stop', short_help='Stops data taking.')
@click.pass_obj
def stop(obj):
    
    '''
    Stop the run
    
    \b
    - disables triggers
    - disables the readout buffer
    '''

    lDevice = obj.mDevice
    lPartId = obj.mPartitionId

    lGlobalNode = lDevice.getNode('master.global')
    lPartNode = lDevice.getNode('master.partition')

    # Select the desired partition
    lGlobalNode.getNode('csr.ctrl.part_sel').write(lPartId)
    lDevice.dispatch()

    lPartNode.stop()

# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
def printCounters( aTopNode, aSubNodes ):

    lNumCtrs = 0x10
    lBlocks = []
    # lBlocks = [ aTopNode.getNode(lKey).readBlock(lNumCtrs) for lKey in aSubNodes ]

    # try:
    #     aTopNode.getClient().dispatch()
    # except uhal.exception as e:
    #     for b in lBlocks:
    #         print (b.valid())
    #     raise SystemExit(0)
    
    for lKey in aSubNodes:
        try:
            ctrs = aTopNode.getNode(lKey).readBlock(lNumCtrs)
            aTopNode.getClient().dispatch()
            lBlocks.append(ctrs.value())

        except uhal.exception as e:
            print ('Failed to read ', lKey)
            lBlocks.append([None]*lNumCtrs)

    # Just a bit of math
    lCellWidth = 10
    kCellFmt = ' {{:^{}}} '.format(lCellWidth)
    kTitleCellFmt = ' {{:^{}}} '.format((lCellWidth+1)*2+1)

    lLineLen = (lCellWidth+2+1)*(len(aSubNodes)*2+1)+1

    # Build the title
    lLine = [kCellFmt.format('')]+[style(kTitleCellFmt.format(aSubNodes[lName]), fg='green') for lName in aSubNodes]
 
    lTitle = '|'.join(['']+lLine+[''])
    echo ( '-'*lLineLen)
    # print ( '-'*len(lTitle))
    echo ( lTitle )

    # Build the title
    lLine = ['Cmd'] +( ['cnts', 'hex' ]*len(aSubNodes) )
    lHdr = '|'.join(['']+[kCellFmt.format(lCell) for lCell in lLine]+[''])
    print ( '-'*lLineLen)
    print ( lHdr )
    print ( '-'*lLineLen)

    for lId in xrange(lNumCtrs):

        lLine = [ (kCommandNames.get(lId,hex(lId))) ]
        for lBlock in lBlocks:
            lLine += [lBlock[lId],hex(lBlock[lId])] if lBlock[lId] is not None else ['fail']*2
        print( '|'.join(['']+[kCellFmt.format(lCell) for lCell in lLine]+['']))
    print ( '-'*lLineLen)
# -----------------

@partition.command('monitor', short_help='Display the status of the timing master.')
@click.pass_obj
@click.option('--watch', '-w', is_flag=True, default=False, help='Turn on automatic refresh')
@click.option('--period','-p', type=click.IntRange(0, 240), default=2, help='Period of automatic refresh')
def monitor(obj, watch, period):
    '''
    Display the master status, accepted and rejected command counters
    '''

    lDevice = obj.mDevice
    lPartId = obj.mPartitionId

    lGlobalNode = lDevice.getNode('master.global')
    lPartNode = lDevice.getNode('master.partition')
    lTStampNode = lDevice.getNode('master.tstamp.ctr')


    while(True):
        if watch:
            click.clear()
        
        echo()
        echo( "-- " + style("Master state", fg='green') + "---")
        echo()

        lScmdGenNode = lDevice.getNode('master.scmd_gen')

        secho( "=> Time sync generator", fg='green')
        lScmdGenCtrlDump = toolbox.readSubNodes(lScmdGenNode.getNode('ctrl'))
        for n in sorted(lScmdGenCtrlDump):
            echo( "  {} {}".format(n, hex(lScmdGenCtrlDump[n])))

        echo()
        secho( "=> Cmd generator control", fg='green')

        lScmdGenChanCtrlDump = toolbox.readSubNodes(lScmdGenNode.getNode('chan_ctrl'))
        for n in sorted(lScmdGenChanCtrlDump):
            echo( "  {} {}".format(n, hex(lScmdGenChanCtrlDump[n])))
        echo()

        # echo()
        # printCounters( lScmdGenNode, {
        #     'actrs': 'Accept counters',
        #     'rctrs': 'Reject counters',
        #     })

        # secho( "=> Spill generator control", fg='green')
        # lDump = toolbox.readSubNodes(lDevice.getNode('master.spill.csr.ctrl'))
        # for n in sorted(lDump):
        #     echo( "  {} {}".format(n, hex(lDump[n])))
        # echo()
        # secho( "=> Spill generator stats", fg='green')
        # lDump = toolbox.readSubNodes(lDevice.getNode('master.spill.csr.stat'))
        # for n in sorted(lDump):
        #     echo( "  {} {}".format(n, hex(lDump[n])))
        # echo()

        secho( "=> Partition {}".format(lPartId), fg='green')
        # Select the desired partition
        lGlobalNode.getNode('csr.ctrl.part_sel').write(lPartId)
        lDevice.dispatch()

        lCtrlDump = toolbox.readSubNodes(lPartNode.getNode('csr.ctrl'))
        lStatDump = toolbox.readSubNodes(lPartNode.getNode('csr.stat'))

        echo( "Control registers" )
        for n in sorted(lCtrlDump):
            echo( "  {} {}".format(n, hex(lCtrlDump[n])))
        echo()
        echo( "Status registers" )
        for n in sorted(lStatDump):
            echo( "  {} {}".format(n, hex(lStatDump[n])))
        echo()

        lTimeStamp = lTStampNode.readBlock(2)
        lEventCtr = lPartNode.getNode('evtctr').read()
        lBufCount = lPartNode.getNode('buf.count').read()
        lDevice.dispatch()

        lTime = int(lTimeStamp[0]) + (int(lTimeStamp[1]) << 32)
        echo( "Timestamp: {} ({})".format(style(str(lTime), fg='blue'), hex(lTime)) )
        echo( "EventCounter: {}".format(lEventCtr))
        lBufState = style('OK', fg='green') if lStatDump['buf_err'] == 0 else style('Error', fg='red')
        # lStatDump['buf_empty']
        echo( "Buffer status: " + lBufState)
        echo( "Buffer occupancy: {}".format(lBufCount))

        echo()
        printCounters( lPartNode, {
            'actrs': 'Accept counters',
            'rctrs': 'Reject counters',
            })

        if watch:
            time.sleep(period)
        else:
            break
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
    # d(0) <= X"aa000600"; -- DAQ word 0
    # d(1) <= X"0000000" & scmd; -- DAQ word 1
    # d(2) <= tstamp(31 downto 0); -- DAQ word 2
    # d(3) <= tstamp(63 downto 32); -- DAQ word 3
    # d(4) <= evtctr; -- DAQ word 4
    # d(5) <= X"00000000"; -- Dummy checksum (not implemented yet)
kEventSize = 6

@partition.command('readback', short_help='Read the timing master readout buffer.')
@click.pass_obj
@click.option('--events/--all', ' /-a', 'readall', default=False, help="Buffer readout mode.\n- events: only completed events are readout.\n- all: the content of the buffer is fully read-out.")
def readback(obj, readall):
    '''
    Read the content of the timing master readout buffer.
    '''
    lDevice = obj.mDevice
    lPartId = obj.mPartitionId

    lGlobalNode = lDevice.getNode('master.global')
    lPartNode = lDevice.getNode('master.partition')


    # Select the desired partition
    lGlobalNode.getNode('csr.ctrl.part_sel').write(lPartId)
    lDevice.dispatch()

    
    lBufCount = lPartNode.getNode('buf.count').read()
    lPartNode.getClient().dispatch()

    echo ( "Words available in readout buffer: "+hex(lBufCount))
    
    # lEventsToRead = int(lBufCount) / kEventSize
    # echo (lEventsToRead)

    lWordsToRead = int(lBufCount) if readall else (int(lBufCount) / kEventSize)*kEventSize

    if lWordsToRead == 0:
        echo("Nothing to read, goodbye!")

    lBufData = lPartNode.getNode('buf.data').readBlock(lWordsToRead)
    lPartNode.getClient().dispatch()

    for i, lWord in enumerate(lBufData):
        echo ( '{:04d} {}'.format(i, hex(lWord)))
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
@master.command('send', short_help='Inject a single command.')
@click.pass_obj
@click.argument('cmd', type=click.Choice(kCommandIDs.keys()))
@click.option('-n', type=int, default=1)
def send(obj, cmd, n):
    '''
    Inject a single command.

    CMD (str): Name of the command to inject '''
    # + ','.join(kCommandIDs.keys())

    lDevice = obj.mDevice

    lGenChanCtrl = lDevice.getNode('master.scmd_gen.chan_ctrl')

    toolbox.resetSubNodes(lGenChanCtrl)

    for i in xrange(n):
        lGenChanCtrl.getNode('type').write(kCommandIDs[cmd])
        lGenChanCtrl.getNode('force').write(0x1)
        lTStamp = lDevice.getNode("master.tstamp.ctr").readBlock(2)
        lDevice.dispatch()

        lGenChanCtrl.getNode('force').write(0x0)
        lDevice.dispatch()
        lTimeStamp = int(lTStamp[0]) + (int(lTStamp[1]) << 32)
        echo("Command sent {}({}) @time {} {}".format(style(cmd, fg='blue'), kCommandIDs[cmd], hex(lTimeStamp), lTimeStamp))
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------

# -----------------
def validate_freq(ctx, param, value):

    lFqMin = 0.5
    lFqMax = 12500.0

    if value < lFqMin or value > lFqMax:    
        raise click.BadParameter(
            'Frequency out of the allowed range {}-{} Hz'.format(lFqMin, lFqMax)
            )

    def div2freq(div):
        return 50e6/(1<<(12+div))

    # Brute force it
    lDeltas = [ abs(value-div2freq(div)) for div in xrange(0x10) ]
    lMinDeltaIdx = min(xrange(len(lDeltas)), key=lDeltas.__getitem__)
    return value, lMinDeltaIdx, div2freq(lMinDeltaIdx)
# -----------------

@master.command()
@click.pass_obj
@click.argument('divider', type=click.IntRange(0, 0xf))
@click.option('--poisson', is_flag=True, default=False, help="Randomize time interval between consecutive triggers.")
def triggen(obj, divider, poisson):
    '''
    \b
    Enables the internal trigger generator.
    Configures the internal command generator to produce triggers at a defined frequency.
    
    Rate = 50 Mhz / 2**( 12 + divider ) for divider between 0 and 15

    \b
    DIVIDER (int): Frequency divider.
    '''

    lDevice = obj.mDevice

    lGenChanCtrl = lDevice.getNode('master.scmd_gen.chan_ctrl')

    lGenChanCtrl.getNode('type').write(kCommandIDs['FakeTrig']) # Set command type = 3 for generator 0
    lGenChanCtrl.getNode('rate_div').write(divider) # Set about 1Hz rate for generator 0
    lGenChanCtrl.getNode('patt').write(poisson) # Set Poisson mode for generator 0
    lGenChanCtrl.getClient().dispatch()
    echo( "> Trigger rate set to " + 
        style(
            "{:.3e} Hz".format(50e6/(1<<(12+divider))),
            fg='yellow'
            )
        ) 
    echo( "> Trigger mode: " + style({False: 'periodic', True: 'poisson'}[poisson], fg='blue') )

    lGenChanCtrl.getNode("en").write(1) # Start the command stream
    lGenChanCtrl.getClient().dispatch()
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
@master.command()
@click.pass_obj
def trigclear(obj):
    '''
    Clear the internal trigger generator.
    '''
    lDevice = obj.mDevice

    lGenChanCtrl = lDevice.getNode('master.scmd_gen.chan_ctrl')

    toolbox.resetSubNodes(lGenChanCtrl)
    echo( "> Command generator configuration cleared" )

# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
# -- cyc_len and spill_len are in units of 1 / (50MHz / 2^24) = 0.34s
@master.command()
@click.pass_obj
def spillgen(obj):
    '''
    \b
    Enables the internal spill generator.
    Configures the internal command generator to produce spills at a defined frequency and length
    
    Rate = 50 Mhz / 2**( 12 + divider ) for divider between 0 and 15
# -- cyc_len and spill_len are in units of 1 / (50MHz / 2^24) = 0.34s

    \b
    FREQ
    '''
    lDevice = obj.mDevice

    lSpillCtrl = lDevice.getNode('master.spill.csr.ctrl')
    lSpillCtrl.getNode('fake_cyc_len').write(16)
    lSpillCtrl.getNode('fake_spill_len').write(8)
    lSpillCtrl.getNode('en_fake').write(1)
    lSpillCtrl.getClient().dispatch()
# ------------------------------------------------------------------------------



# ------------------------------------------------------------------------------
@master.command('sfp', short_help='Query the sfp parameters.')
@click.pass_obj
def sfp(obj):
    '''
    Read the content of the timing master readout buffer.
    '''
    lDevice = obj.mDevice

    lSfp = lDevice.getNode('io.sfp_i2c')
    print ( lSfp )
    print ( lSfp.getSlave('eeprom') )
    print ( hex(lSfp.getSlave('eeprom').getI2CAddress()) )
    # print ( lSfp.getSlave('eeprom').readI2C(0x0) )

    try:
        import IPython
    except ImportError:
        echo('Failed to load IPython')
        return

    echo('Starting IPython - {} connected to variable \'board\''.format( lDevice.id() ))
    IPython.embed()

# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
#    ____        __          _      __ 
#   / __/__  ___/ /__  ___  (_)__  / /_
#  / _// _ \/ _  / _ \/ _ \/ / _ \/ __/
# /___/_//_/\_,_/ .__/\___/_/_//_/\__/ 
#              /_/                     
@cli.group('ept', invoke_without_command=True)
@click.pass_obj
@click.argument('device', callback=validate_device)
def endpoint(obj, device):
    '''
    Endpoint master commands.

    DEVICE: uhal device identifier
    '''

    lDevice = obj.mConnectionManager.getDevice(str(device))
    if obj.mTimeout:
        lDevice.setTimeoutPeriod(obj.mTimeout)

    echo('Created endpoint device ' + style(lDevice.id(), fg='blue'))

    lVersion = lDevice.getNode('endpoint.version').read()
    lDevice.dispatch()
    echo("Endpoint FW version: "+hex(lVersion))

    obj.mDevice = lDevice
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
@endpoint.command('enable')
@click.pass_obj
@click.option('--on/--off', default=True, help='enable/disable the endpoint')
@click.option('--partition', '-p', type=click.IntRange(0,4), help='Target partition', default=0)
def enable(obj, on, partition):
    '''
    Activate timing endpoint wrapper block.
    '''

    lEndPointNode = obj.mDevice.getNode('endpoint')
    lEndPointNode.getNode('csr.ctrl.tgrp').write(partition)
    lEndPointNode.getClient().dispatch()
    lEndPointNode.getNode('csr.ctrl.ep_en').write(on)
    lEndPointNode.getNode('csr.ctrl.buf_en').write(on)
    lEndPointNode.getClient().dispatch()
    echo("> Endpoint " + style("activated in partition {}".format(partition ) if on else "deactivated", fg='blue'))
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
# -----------------
kEpStates = collections.OrderedDict([
    (0b0000,'Standing by'), #when W_RST, -- Starting state after reset
    (0b0001,'Waiting SFP for signal'), #when W_SFP, -- Waiting for SFP LOS to go low
    (0b0010,'Waiting CDR lock'), #when W_CDR, -- Waiting for CDR lock
    (0b0011,'Waiting for comman alignment'), #when W_ALIGN, -- Waiting for comma alignment, stable 50MHz phase
    (0b0100,'Waiting for good frequency checl'), #when W_FREQ, -- Waiting for good frequency check
    (0b0101,'Waiting for 8b10 decoder good packet'), #when W_LOCK, -- Waiting for 8b10 decoder good packet
    (0b0110,'Waiting for time stamp initialisation'), #when W_RDY, -- Waiting for time stamp initialisation
    (0b1000,'Ready'), #when RUN, -- Good to go
    (0b1100,'Error in Rx'), #when ERR_R, -- Error in rx
    (0b1101,'Error in time stamp check'), #when ERR_T; -- Error in time stamp check
    ])
# -----------------

@endpoint.command('monitor', short_help='Display the status of timing endpoint.')
@click.pass_obj
@click.option('--watch', '-w', is_flag=True, default=False, help='Turn on automatic refresh')
@click.option('--period', '-p', type=click.IntRange(0, 240), default=2, help='Period of automatic refresh')
def monitor(obj, watch, period):

# def monitor(obj, watch, period):
    '''
    Display the endpoint status, accepted and rejected command counters
    '''

    lDevice = obj.mDevice
    lEndPointNode = lDevice.getNode('endpoint')
    lTStampNode = lEndPointNode.getNode('tstamp')
    lEvCtrNode = lEndPointNode.getNode('evtctr')
    lBufCountNode = lEndPointNode.getNode('buf.count')

    while(True):
        if watch:
            click.clear()
        
        lTimeStamp = lTStampNode.readBlock(2)
        lEventCtr = lEvCtrNode.read()
        lBufCount = lBufCountNode.read()
        lDevice.dispatch()

        lTime = int(lTimeStamp[0]) + (int(lTimeStamp[1]) << 32)

        echo()
        echo( "-- " + style("Endpoint state", fg='green') + "---")
        echo()

        lCtrlDump = toolbox.readSubNodes(lEndPointNode.getNode('csr.ctrl'))
        lStatDump = toolbox.readSubNodes(lEndPointNode.getNode('csr.stat'))

        echo( "Status registers" )
        for n in sorted(lStatDump):
            echo( "  {} {}".format(n, hex(lStatDump[n])))
        echo()
        echo( 'Endpoint state: {} ({})'.format(kEpStates[int(lStatDump['ep_stat'])], hex(lStatDump['ep_stat'])))

        echo ()
        echo( "Partition: {}".format(lCtrlDump['tgrp']))
        echo( "Timestamp: {} ({})".format(style(str(lTime), fg='blue'), hex(lTime)) )
        echo( "EventCounter: {}".format(lEventCtr))
        lBufState = style('OK', fg='green') if lStatDump['buf_err'] == 0 else style('Error', fg='red')
        # lStatDump['buf_empty']
        echo( "Buffer status: " + lBufState)
        echo( "Buffer occupancy: {}".format(lBufCount))
        echo ()

        # secho ("Received commands counters", fg='green')
        # printCounters(lEndPointNode.getNode('ctrs'))
        
        echo()
        printCounters( lEndPointNode, {
            'ctrs': 'Received counters',
            })
        if watch:
            time.sleep(period)
        else:
            break
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
@endpoint.command('readback', short_help='Read the content of the endpoint master readout buffer.')
@click.pass_obj
@click.option('--events/--all', ' /-a', 'readall', default=False, help="Buffer readout mode.\n- events: only completed events are readout.\n- all: the content of the buffer is fully read-out.")
def readback(obj, readall):
    '''
    Read the content of the endpoint master readout buffer.
    '''
    lDevice = obj.mDevice
    
    lEndPointNode = lDevice.getNode('endpoint')
    lBufCount = lEndPointNode.getNode('buf.count').read()
    lEndPointNode.getClient().dispatch()

    echo ( "Words available in readout buffer: "+hex(lBufCount))
    
    # lEventsToRead = int(lBufCount) / kEventSize
    # echo (lEventsToRead)

    lWordsToRead = int(lBufCount) if readall else (int(lBufCount) / kEventSize)*kEventSize

    echo (lWordsToRead )
    if lWordsToRead == 0:
        echo("Nothing to read, goodbye!")

    lBufData = lEndPointNode.getNode('buf.data').readBlock(lWordsToRead)
    lEndPointNode.getClient().dispatch()

    for i, lWord in enumerate(lBufData):
        echo ( '{:04d} {}'.format(i, hex(lWord)))
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
if __name__ == '__main__':
    cli(obj=PDTContext())
# ------------------------------------------------------------------------------
